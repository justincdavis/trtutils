# Copyright (c) 2024 Justin Davis (davisjustin302@gmail.com)
#
# MIT License
# ruff: noqa: S603, S607
"""Benchmark trtutils againist popular frameworks."""

from __future__ import annotations

import argparse
import json
import statistics
import subprocess
import time
from pathlib import Path

import cv2
from ultralytics import YOLO as ULTRALYTICS_YOLO

from trtutils.impls.yolo import YOLO as TRTUTILS_YOLO
from trtutils.trtexec import build_engine

WARMUP_ITERS = 1
BENCH_ITERS = 1000


def main() -> None:
    """Run the benchmarking."""
    parser = argparse.ArgumentParser("Run benchmarking againist popular frameworks.")
    parser.add_argument(
        "--device",
        type=str,
        required=True,
        help="The name of the device you are generating a benchmark on.",
    )
    args = parser.parse_args()

    # get the paths of the ultralytics weights
    repo = Path(__file__).parent.parent
    weight_path = repo / "data" / "ultralytics" / "yolov10n.pt"
    weight_path = weight_path.resolve()

    # small helper func
    def get_results(data: list[float]) -> dict[str, float]:
        return {
            "mean": statistics.mean(data),
            "median": statistics.median(data),
            "min": min(data),
            "max": max(data),
        }

    # overall results
    results: dict[str, dict[str, dict[str, dict[str, float]]]] = {}

    # repeat for each image size
    for imgsz in [160, 320, 480, 640, 800, 960, 1120, 1280]:
        modelname = f"yolov10n_{imgsz}"
        sub_result: dict[str, dict[str, dict[str, float]]] = {}

        # export the weights to tensorrt engines
        subprocess.run(
            [
                "yolo",
                "export",
                f"model={weight_path}",
                "format=engine",
                f"imgsz={imgsz}",
                "half",
            ],
            check=True,
        )

        # the path is the same, but with the suffix replaced
        utrt_path = weight_path.with_suffix(".engine")

        # the path to the onnx weights generated by ultralytics
        onnx_path = weight_path.with_suffix(".onnx")

        # build the raw tensorrt engine using trtexec
        # will inherit the input shape of (imgsz X imgsz)
        trt_path = weight_path.with_suffix(".trt")
        build_engine(
            onnx_path,
            trt_path,
            fp16=True,
        )

        # at this point verify all the files exist
        if not utrt_path.exists():
            err_msg = f"ultralytics TensorRT engine not found: {utrt_path}"
            raise FileNotFoundError(err_msg)
        if not trt_path.exists():
            err_msg = f"trtutils TensorRT engine not found: {trt_path}"
            raise FileNotFoundError(err_msg)

        # run the benchmarking
        image = cv2.imread(str((repo / "data" / "horse.jpg").resolve()))

        # ultralytics
        u_yolo = ULTRALYTICS_YOLO(model=utrt_path, task="detect", verbose=False)
        # warmup the u_yolo model once to match the trtutils engine
        for _ in range(WARMUP_ITERS):
            u_yolo(image, imgsz=imgsz, verbose=False)
        u_timing: list[float] = []
        for _ in range(BENCH_ITERS):
            t0 = time.perf_counter()
            u_yolo(image, imgsz=imgsz, verbose=False)
            u_timing.append(time.perf_counter() - t0)
        del u_yolo

        # trtutils
        trt_yolo = TRTUTILS_YOLO(
            engine_path=trt_path,
            warmup_iterations=WARMUP_ITERS,
            warmup=True,
            verbose=False,
        )
        t_timing: list[float] = []
        for _ in range(BENCH_ITERS):
            t0 = time.perf_counter()
            trt_yolo.end2end(image)
            t_timing.append(time.perf_counter() - t0)
        del trt_yolo

        # generate the stats for each
        sub_result["ultralytics"][str(imgsz)] = get_results(u_timing)
        sub_result["trtutils"][str(imgsz)] = get_results(t_timing)

        # write to overall
        results[modelname] = sub_result

    # write the results
    data_dir = Path(__file__).parent / "data"
    data_dir.mkdir(parents=True, exist_ok=True)
    file_path = data_dir / f"{args.device}.json"
    with file_path.open("w+") as f:
        json.dump(results, f, ident=4)


if __name__ == "__main__":
    main()
