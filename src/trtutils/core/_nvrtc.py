# Copyright (c) 2024 Justin Davis (davisjustin302@gmail.com)
#
# MIT License
# ruff: noqa: TRY004
from __future__ import annotations

import contextlib
import logging
from threading import Lock
from typing import TypeVar

import numpy as np

# suppress pycuda import error for docs build
with contextlib.suppress(Exception):
    from cuda import cuda, nvrtc  # type: ignore[import-untyped, import-not-found]

from ._cuda import cuda_call
from ._memory import _MEM_ALLOC_LOCK

_NVRTC_LOCK = Lock()

_log = logging.getLogger(__name__)


def check_nvrtc_err(err: nvrtc.nvrtcResult) -> None:
    """
    Check if a NVRTC error occured and raise an exception if so.

    Parameters
    ----------
    err : nvrtc.nvrtcResult
        The NVRTC return code to check.

    Raises
    ------
    RuntimeError
        If a NVRTC error occured.

    """
    if err != nvrtc.nvrtcResult.NVRTC_SUCCESS:
        err_msg = f"NVRTC Error: {err} -> "
        err_msg += f"{nvrtc_call(nvrtc.nvrtcGetErrorString(err))}"
        raise RuntimeError(err_msg)


T = TypeVar("T")


def nvrtc_call(call: tuple[nvrtc.nvrtcResult, T]) -> T:
    """
    Call a NVRTC function and check for errors.

    Parameters
    ----------
    call : tuple[cuda.CUresult | cudart.cudaError_t, T]
        The NVRTC function to call and its arguments.

    Returns
    -------
    T
        The result of the NVRTC function call.

    """
    err, res = call[0], call[1:]
    check_nvrtc_err(err)
    if len(res) == 1:
        return res[0]
    return res


def compile_kernel(
    kernel: str,
    name: str,
    opts: list[str] | None = None,
) -> np.char.chararray:
    """
    Compile a CUDA kernel into PTX using NVRTC.

    Parameters
    ----------
    kernel : str
        The kernel definition in CUDA.
    name : str
        The name of the kernel in the definition.
    opts : list[str]
        The optional additional arguments to pass to NVRTC during
        the compilation of the kernel.

    Returns
    -------
    tuple[np.char.chararray, str]
        The compiled PTX kernel and the kernel name.

    """
    kernel_bytes = kernel.encode()
    kernel_name_bytes = f"{name}.cu".encode()

    _log.debug(f"Compiling kernel: {name}")

    # compile the kernel
    with _NVRTC_LOCK, _MEM_ALLOC_LOCK:
        prog = nvrtc_call(
            nvrtc.nvrtcCreateProgram(kernel_bytes, kernel_name_bytes, 0, [], []),
        )
        opts = [] if opts is None else opts
        nvrtc_call(nvrtc.nvrtcCompileProgram(prog, len(opts), opts))

        # generate the actual kernel ptx
        ptx_size = nvrtc_call(nvrtc.nvrtcGetPTXSize(prog))
        ptx_buffer = b"\0" * ptx_size
        nvrtc_call(nvrtc.nvrtcGetPTX(prog, ptx_buffer))

    return np.char.array(ptx_buffer)


def load_kernel(
    kernel_ptx: np.char.chararray,
    name: str,
) -> tuple[cuda.CUmodule, cuda.CUkernel]:
    """
    Load a kernel from a PTX definition.

    Parameters
    ----------
    kernel_ptx: np.char.chararray
        The PTX generated by NVRTC, use the compile_kernel function.
    name: str
        The name of the kernel inside the PTX definiton.

    Returns
    -------
    tuple[cuda.CUmodule, cuda.CUkernel]
        The CUDA module and kernel

    """
    _log.debug(f"Loading kernel: {name} from PTX")
    with _NVRTC_LOCK, _MEM_ALLOC_LOCK:
        module: cuda.CUmodule = cuda_call(cuda.cuModuleLoadData(kernel_ptx.ctypes.data))
        kernel: cuda.CUkernel = cuda_call(
            cuda.cuModuleGetFunction(module, name.encode()),
        )
    return module, kernel


def compile_and_load_kernel(
    kernel_code: str,
    name: str,
    opts: list[str] | None = None,
) -> tuple[cuda.CUmodule, cuda.CUkernel]:
    """
    Compile and load a kernel from source definiton.

    Parameters
    ----------
    kernel_code : str
        The code definition of the kernel.
    name : str
        The name of the kernel.
    opts : list[str]
        The optional additional arguments to pass to NVRTC during
        the compilation of the kernel.

    Returns
    -------
    tuple[cuda.CUmodule, cuda.CUkernel]
        The CUDA module and kernel

    """
    ptx = compile_kernel(kernel_code, name, opts)
    module, kernel = load_kernel(ptx, name)
    return module, kernel
